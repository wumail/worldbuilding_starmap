<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Procedural Skybox - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        /* æœç´¢UIæ ·å¼ */
        #search-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 100;
        }

        #search-input {
            width: 250px;
            padding: 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #222;
            color: white;
            font-size: 14px;
        }

        #search-results {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .result-item {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            transition: background 0.2s;
        }

        .result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .result-item.selected {
            background: rgba(100, 150, 255, 0.3);
        }

        .star-info {
            font-size: 12px;
            color: #aaa;
            margin-top: 3px;
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 300px;
            display: none;
        }

        #reset-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid #444;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 100;
        }

        #reset-button:hover {
            background: rgba(50, 50, 50, 0.9);
        }

        #color-toggle-button {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid #444;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 100;
        }

        #color-toggle-button:hover {
            background: rgba(50, 50, 50, 0.9);
        }
    </style>
</head>

<body>

    <!-- æœç´¢é¢æ¿ -->
    <div id="search-panel">
        <input type="text" id="search-input" placeholder="æœç´¢æ˜Ÿæ˜Ÿ (ä¾‹å¦‚: Sys_1, Bg_100)">

        <!-- è§†æ˜Ÿç­‰ç­›é€‰ -->
        <div style="margin-top: 10px; font-size: 12px;">
            <label>è§†æ˜Ÿç­‰èŒƒå›´: <span id="mag-range-display">-2 åˆ° 7</span></label>
            <div style="display: flex; gap: 10px; margin-top: 5px;">
                <input type="range" id="mag-min" min="-2" max="7" value="-2" step="0.5" style="flex: 1;">
                <input type="range" id="mag-max" min="-2" max="7" value="7" step="0.5" style="flex: 1;">
            </div>
        </div>

        <!-- æ’åºæŒ‰é’® -->
        <div style="margin-top: 10px; display: flex; gap: 5px;">
            <button id="sort-bright" style="flex: 1; padding: 5px; font-size: 11px; cursor: pointer;">â­ æœ€äº®ä¼˜å…ˆ</button>
            <button id="sort-dim" style="flex: 1; padding: 5px; font-size: 11px; cursor: pointer;">ğŸŒ‘ æœ€æš—ä¼˜å…ˆ</button>
            <button id="sort-near" style="flex: 1; padding: 5px; font-size: 11px; cursor: pointer;">ğŸ“ æœ€è¿‘ä¼˜å…ˆ</button>
        </div>

        <div id="search-results"></div>
    </div>

    <!-- ä¿¡æ¯é¢æ¿ -->
    <div id="info-panel">
        <h3 id="star-name" style="margin-top: 0;"></h3>
        <div id="star-details"></div>
    </div>

    <!-- é‡ç½®æŒ‰é’® -->
    <button id="reset-button">è¿”å›åŸç‚¹</button>

    <!-- é¢œè‰²åˆ‡æ¢æŒ‰é’® -->
    <button id="color-toggle-button">åˆ‡æ¢ä¸ºç™½è‰²</button>

    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // 1. åŸºç¡€åœºæ™¯è®¾ç½®
        // ==========================================
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 0.1);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.rotateSpeed = 0.5;

        // ==========================================
        // 2. æ•°æ®å­˜å‚¨
        // ==========================================
        let starsData = [];
        let starMaterial = null;  // ä¿å­˜æ˜Ÿæ˜Ÿæè´¨çš„å¼•ç”¨
        let selectedStar = null;
        let highlightMarker = null;

        // ==========================================
        // 3. è‡ªå®šä¹‰ Shader
        // ==========================================
        const vertexShader = `
            attribute float mag;
            attribute vec3 color;
            varying vec3 vColor;
            varying float vIntensity; // æ–°å¢ï¼šå‘ç‰‡å…ƒä¼ é€’ç‰©ç†äº®åº¦

            void main() {
                vColor = color;
                
                // 1. åº”ç”¨æ™®æ ¼æ£®å…¬å¼è®¡ç®—ç‰©ç†äº®åº¦ (ä»¥0ç­‰æ˜Ÿä¸ºåŸºå‡† 1.0)
                // I = 10^(-0.4 * m)
                float intensity = pow(10.0, -0.4 * mag);
                vIntensity = intensity;
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // 2. æ”¹é€ åçš„å¯¹æ•°ç¼©æ”¾å°ºå¯¸é€»è¾‘
                // ç†ç”±ï¼šç›´æ¥ç”¨å¼ºåº¦æ§åˆ¶å°ºå¯¸ä¼šå¯¼è‡´äº®æ˜Ÿè¿‡å¤§æˆ–æš—æ˜Ÿæ¶ˆå¤±
                // ä½¿ç”¨ log æ˜ å°„å¯ä»¥æ¨¡æ‹Ÿäººçœ¼çš„éçº¿æ€§æ„ŸçŸ¥ï¼Œæ—¢ä¿ç•™äº†äº®æ˜Ÿçš„åœ°ä½ï¼Œåˆè®©æš—æ˜Ÿæ¸…æ™°å¯è§
                float baseSize = 70.0; 
                float sizeFactor = log2(intensity * 10.0 + 1.01); 
                
                // ç»“åˆè·ç¦»è¡°å‡
                gl_PointSize = baseSize * sizeFactor * (1000.0 / length(mvPosition.xyz));
                
                // é™åˆ¶å°ºå¯¸èŒƒå›´ã€‚4.4 æ˜¯ä¸ºäº†ä¿è¯ 6.5 ç­‰æ˜Ÿåœ¨è¿œå¤„ä¾ç„¶èƒ½å  1-2 åƒç´ ï¼Œé¿å…é—ªçƒ
                gl_PointSize = clamp(gl_PointSize, 4.0, 64.0);
            }
        `;

        const fragmentShader = `
            uniform bool useWhiteColor;
            varying vec3 vColor;
            varying float vIntensity; // æ¥æ”¶ç‰©ç†äº®åº¦

            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                if (dist > 0.5) discard;
                
                // 1. æ¨¡æ‹Ÿç‚¹æ‰©æ•£å‡½æ•° (PSF)
                // æ ¸å¿ƒåŒºåŸŸ (Core) æ¨¡æ‹Ÿæ˜Ÿæ˜Ÿå®ä½“ï¼Œè¾¹ç¼˜ (Glow) æ¨¡æ‹Ÿå…‰æ™•
                // å¼•å…¥ vIntensity è®©äº®æ˜Ÿçœ‹èµ·æ¥æ›´â€œé€šé€â€
                float core = 1.0 - smoothstep(0.0, 0.2, dist);
                float glow = (1.0 - smoothstep(0.0, 0.5, dist)) * 0.4;
                
                // 2. è®¡ç®—æœ€ç»ˆå¼ºåº¦
                // ç‰©ç†äº®åº¦é«˜çš„æ˜Ÿæ˜Ÿï¼Œä¸­å¿ƒå’Œå…‰æ™•ä¼šæ›´äº®
                float intensity = (core + glow) * (vIntensity + 0.6);
                
                // 3. alpha è®¡ç®—
                // ä½¿ç”¨å¹³æ»‘æ·¡å‡ºï¼Œç¡®ä¿æ˜Ÿæ˜Ÿè¾¹ç¼˜ä¸ç”Ÿç¡¬
                float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                
                // 4. é¢œè‰²ä¸ç™½è‰²åˆ‡æ¢é€»è¾‘
                vec3 starColor = useWhiteColor ? vec3(1.0) : vColor;
                
                // äº®æ˜Ÿï¼ˆvIntensity > 1.0ï¼‰ä¼šè‡ªåŠ¨å‘ˆç°å‡ºä¸€ç§è¿‡æ›çš„ç™½è‰²å€¾å‘ï¼Œæ›´ç¬¦åˆæ‘„å½±è§„å¾‹
                vec3 finalColor = mix(starColor, vec3(1.0), clamp(vIntensity * 0.1, 0.0, 1.0));
                
                gl_FragColor = vec4(finalColor * intensity, alpha);
            }
        `;

        // ==========================================
        // 4. é«˜äº®æ ‡è®°
        // ==========================================
        function createHighlightMarker() {
            // åˆ›å»ºä¸€ä¸ªç»„æ¥åŒ…å«å¤šä¸ªæ ‡è®°å…ƒç´ 
            highlightMarker = new THREE.Group();

            // 1. ä¸­åœˆå…‰ç¯
            const ring2Geometry = new THREE.RingGeometry(18, 21, 32);
            const ring2Material = new THREE.MeshBasicMaterial({
                color: 0x666666,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const ring2 = new THREE.Mesh(ring2Geometry, ring2Material);
            highlightMarker.add(ring2);

            // 2. åå­—å‡†æ˜Ÿ - åˆ†æ®µæ˜¾ç¤ºï¼Œä¸­å¿ƒç•™ç©ºä¸é®æŒ¡æ˜Ÿæ˜Ÿ
            const crossMaterial = new THREE.LineBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 1.0,
                linewidth: 3
            });

            // æ°´å¹³çº¿ - åˆ†ä¸ºå·¦å³ä¸¤æ®µ
            const crossGeometry1 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-40, 0, 0),
                new THREE.Vector3(-12, 0, 0)
            ]);
            const crossGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(12, 0, 0),
                new THREE.Vector3(40, 0, 0)
            ]);
            // å‚ç›´çº¿ - åˆ†ä¸ºä¸Šä¸‹ä¸¤æ®µ
            const crossGeometry3 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -40, 0),
                new THREE.Vector3(0, -12, 0)
            ]);
            const crossGeometry4 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 12, 0),
                new THREE.Vector3(0, 40, 0)
            ]);

            const crossLine1 = new THREE.Line(crossGeometry1, crossMaterial);
            const crossLine2 = new THREE.Line(crossGeometry2, crossMaterial);
            const crossLine3 = new THREE.Line(crossGeometry3, crossMaterial);
            const crossLine4 = new THREE.Line(crossGeometry4, crossMaterial);
            highlightMarker.add(crossLine1);
            highlightMarker.add(crossLine2);
            highlightMarker.add(crossLine3);
            highlightMarker.add(crossLine4);

            highlightMarker.visible = false;
            scene.add(highlightMarker);
        }

        // ==========================================
        // 5. é“¶é“å’Œå¤©ææ ‡è®°
        // ==========================================
        function createGalacticPlane() {
            // åˆ›å»ºé“¶é“å¹³é¢åœ†å½¢çº¿æ¡
            const segments = 128;
            const radius = 1000;
            const points = [];

            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    Math.cos(theta) * radius,
                    Math.sin(theta) * radius,
                    0
                ));
            }

            const galacticPlaneGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const galacticPlaneMaterial = new THREE.LineBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.5,
                linewidth: 2
            });
            const galacticPlane = new THREE.Line(galacticPlaneGeometry, galacticPlaneMaterial);

            // é“¶é“åœ¨XYå¹³é¢ä¸Šï¼Œå‚ç›´äºå¤©è½´ï¼ˆZè½´ï¼‰
            // ä¸éœ€è¦æ—‹è½¬ï¼Œä¿æŒåœ¨XYå¹³é¢
            scene.add(galacticPlane);

            // æ·»åŠ é“¶é“æ ‡ç­¾çº¿
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(1000, 0, 0),
                new THREE.Vector3(1100, 0, 0)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.6
            });
            const labelLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(labelLine);

            // åˆ›å»ºé“¶é“æ–‡å­—æ ‡ç­¾ï¼ˆä½¿ç”¨ç²¾çµï¼‰
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#4488ff';
            context.font = 'Bold 40px Arial';
            context.fillText('é“¶é“é¢', 10, 45);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.2
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(1200, 0, 0);
            sprite.scale.set(200, 50, 1);
            scene.add(sprite);
        }

        function createCelestialPoles() {
            // // åŒ—å¤©æ (North Celestial Pole) - Zè½´æ­£æ–¹å‘
            // const northPoleGeometry = new THREE.SphereGeometry(15, 16, 16);
            // const northPoleMaterial = new THREE.MeshBasicMaterial({
            //     color: 0xff6666,
            //     transparent: true,
            //     opacity: 0.1
            // });
            // const northPole = new THREE.Mesh(northPoleGeometry, northPoleMaterial);
            // northPole.position.set(0, 0, 1000);
            // scene.add(northPole);

            // åŒ—å¤©ææ ‡ç­¾
            const canvasNorth = document.createElement('canvas');
            const contextNorth = canvasNorth.getContext('2d');
            canvasNorth.width = 256;
            canvasNorth.height = 64;
            contextNorth.fillStyle = '#ff6666';
            contextNorth.font = 'Bold 40px Arial';
            contextNorth.fillText('N', 10, 45);

            const textureNorth = new THREE.CanvasTexture(canvasNorth);
            const spriteNorthMaterial = new THREE.SpriteMaterial({
                map: textureNorth,
                transparent: true,
                opacity: 0.4
            });
            const spriteNorth = new THREE.Sprite(spriteNorthMaterial);
            spriteNorth.position.set(0, 80, 1000);
            spriteNorth.scale.set(200, 50, 1);
            scene.add(spriteNorth);

            // // å—å¤©æ (South Celestial Pole) - Zè½´è´Ÿæ–¹å‘
            // const southPoleGeometry = new THREE.SphereGeometry(15, 16, 16);
            // const southPoleMaterial = new THREE.MeshBasicMaterial({
            //     color: 0x66ff66,
            //     transparent: true,
            //     opacity: 0.1
            // });
            // const southPole = new THREE.Mesh(southPoleGeometry, southPoleMaterial);
            // southPole.position.set(0, 0, -1000);
            // scene.add(southPole);

            // å—å¤©ææ ‡ç­¾
            const canvasSouth = document.createElement('canvas');
            const contextSouth = canvasSouth.getContext('2d');
            canvasSouth.width = 256;
            canvasSouth.height = 64;
            contextSouth.fillStyle = '#66ff66';
            contextSouth.font = 'Bold 40px Arial';
            contextSouth.fillText('S', 10, 45);

            const textureSouth = new THREE.CanvasTexture(canvasSouth);
            const spriteSouthMaterial = new THREE.SpriteMaterial({
                map: textureSouth,
                transparent: true,
                opacity: 0.4
            });
            const spriteSouth = new THREE.Sprite(spriteSouthMaterial);
            spriteSouth.position.set(0, -80, -1000);
            spriteSouth.scale.set(200, 50, 1);
            scene.add(spriteSouth);
        }

        function createCelestialMeridians() {
            // åˆ›å»º52æ¡å¤©ç»çº¿ï¼ˆèµ¤ç»çº¿ï¼‰ï¼Œä»åŒ—å¤©æåˆ°å—å¤©æ
            const numMeridians = 52;
            const angleStep = (Math.PI * 2) / numMeridians;
            const radius = 1000;
            const segments = 64; // æ¯æ¡ç»çº¿çš„åˆ†æ®µæ•°

            for (let i = 0; i < numMeridians; i++) {
                const angle = i * angleStep;
                const points = [];

                // ç»çº¿è¿æ¥è‡³80åº¦çº¬çº¿ï¼ˆ10åº¦å’Œ170åº¦ï¼‰
                const startPhi = (10 / 180) * Math.PI; // 10åº¦çº¬çº¿ï¼ˆåŒ—çº¬80åº¦ï¼‰
                const endPhi = (170 / 180) * Math.PI;   // 170åº¦çº¬çº¿ï¼ˆå—çº¬80åº¦ï¼‰

                // ä»å—çº¬80åº¦åˆ°åŒ—çº¬80åº¦ç»˜åˆ¶åŠåœ†å¼§
                for (let j = 0; j <= segments; j++) {
                    const phi = startPhi + (j / segments) * (endPhi - startPhi);
                    const z = radius * Math.cos(phi);
                    const r = radius * Math.sin(phi); // åœ¨XYå¹³é¢ä¸Šçš„åŠå¾„

                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);

                    points.push(new THREE.Vector3(x, y, z));
                }

                const meridianGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const meridianMaterial = new THREE.LineBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.2,
                    linewidth: 1
                });
                const meridianLine = new THREE.Line(meridianGeometry, meridianMaterial);
                scene.add(meridianLine);

                // æ·»åŠ åº¦æ•°æ ‡ç­¾ï¼ˆåœ¨èµ¤é“ä½ç½®ï¼Œæ¯éš”ä¸€æ¡ç»çº¿æ ‡è®°ï¼‰
                if (i % 2 === 0) { // æ¯éš”ä¸€æ¡ç»çº¿æ ‡è®°ï¼Œé¿å…è¿‡äºæ‹¥æŒ¤
                    const degrees = Math.round((i / numMeridians) * 360);
                    const equatorPhi = Math.PI / 2; // èµ¤é“ä½ç½®
                    const labelR = radius * Math.sin(equatorPhi);
                    const labelZ = radius * Math.cos(equatorPhi);
                    const labelX = labelR * Math.cos(angle);
                    const labelY = labelR * Math.sin(angle);

                    // åˆ›å»ºæ–‡å­—æ ‡ç­¾
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 64;
                    context.fillStyle = '#888888';
                    context.font = 'Bold 32px Arial';
                    context.textAlign = 'center';
                    context.fillText(degrees + 'Â°', 64, 45);

                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.1
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(labelX * 1.05, labelY * 1.05, labelZ);
                    sprite.scale.set(80, 40, 1);
                    scene.add(sprite);
                }
            }
        }

        function createPolarCrosses() {
            // åœ¨ä¸¤æåˆ›å»ºåå­—ï¼Œè¿æ¥0ã€13ã€26ã€39ç»çº¿
            const crossMeridians = [0, 13, 26, 39];
            const numMeridians = 52;
            const angleStep = (Math.PI * 2) / numMeridians;
            const radius = 1000;

            // åŒ—æåå­—ï¼ˆ10åº¦çº¬çº¿ä½ç½®ï¼‰
            const northPhi = (10 / 180) * Math.PI;
            const northR = radius * Math.sin(northPhi);
            const northZ = radius * Math.cos(northPhi);

            // å—æåå­—ï¼ˆ170åº¦çº¬çº¿ä½ç½®ï¼‰
            const southPhi = (170 / 180) * Math.PI;
            const southR = radius * Math.sin(southPhi);
            const southZ = radius * Math.cos(southPhi);

            // ç»˜åˆ¶åå­—çº¿ï¼ˆè¿æ¥å¯¹è§’çš„ç»çº¿ï¼‰
            for (let i = 0; i < 2; i++) {
                const idx1 = crossMeridians[i];
                const idx2 = crossMeridians[i + 2];

                const angle1 = idx1 * angleStep;
                const angle2 = idx2 * angleStep;

                // åŒ—æåå­—çº¿
                const northPoints = [
                    new THREE.Vector3(
                        northR * Math.cos(angle1),
                        northR * Math.sin(angle1),
                        northZ
                    ),
                    new THREE.Vector3(
                        northR * Math.cos(angle2),
                        northR * Math.sin(angle2),
                        northZ
                    )
                ];

                const northGeometry = new THREE.BufferGeometry().setFromPoints(northPoints);
                const northMaterial = new THREE.LineBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.2,
                    linewidth: 2
                });
                const northLine = new THREE.Line(northGeometry, northMaterial);
                scene.add(northLine);

                // å—æåå­—çº¿
                const southPoints = [
                    new THREE.Vector3(
                        southR * Math.cos(angle1),
                        southR * Math.sin(angle1),
                        southZ
                    ),
                    new THREE.Vector3(
                        southR * Math.cos(angle2),
                        southR * Math.sin(angle2),
                        southZ
                    )
                ];

                const southGeometry = new THREE.BufferGeometry().setFromPoints(southPoints);
                const southMaterial = new THREE.LineBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.2,
                    linewidth: 2
                });
                const southLine = new THREE.Line(southGeometry, southMaterial);
                scene.add(southLine);
            }
        }

        function createPolarCircles() {
            // åˆ›å»ºæç‚¹åœ†ç¯ï¼Œè¿æ¥ç»çº¿ç«¯ç‚¹ï¼ˆ80åº¦çº¬çº¿ï¼‰
            const radius = 1000;
            const segments = 128;

            // åŒ—æåœ†ç¯ï¼ˆ10åº¦çº¬çº¿ï¼Œå³åŒ—çº¬80åº¦ï¼‰
            const northPhi = (10 / 180) * Math.PI;
            const northR = radius * Math.sin(northPhi); // åœ†ç¯åœ¨XYå¹³é¢ä¸Šçš„åŠå¾„
            const northZ = radius * Math.cos(northPhi); // Zåæ ‡

            const northPoints = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                northPoints.push(new THREE.Vector3(
                    northR * Math.cos(theta),
                    northR * Math.sin(theta),
                    northZ
                ));
            }

            const northGeometry = new THREE.BufferGeometry().setFromPoints(northPoints);
            const northMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 0.2,
                linewidth: 1
            });
            const northCircle = new THREE.Line(northGeometry, northMaterial);
            scene.add(northCircle);

            // å—æåœ†ç¯ï¼ˆ170åº¦çº¬çº¿ï¼Œå³å—çº¬80åº¦ï¼‰
            const southPhi = (170 / 180) * Math.PI;
            const southR = radius * Math.sin(southPhi); // åœ†ç¯åœ¨XYå¹³é¢ä¸Šçš„åŠå¾„
            const southZ = radius * Math.cos(southPhi); // Zåæ ‡

            const southPoints = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                southPoints.push(new THREE.Vector3(
                    southR * Math.cos(theta),
                    southR * Math.sin(theta),
                    southZ
                ));
            }

            const southGeometry = new THREE.BufferGeometry().setFromPoints(southPoints);
            const southMaterial = new THREE.LineBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 0.2,
                linewidth: 1
            });
            const southCircle = new THREE.Line(southGeometry, southMaterial);
            scene.add(southCircle);
        }

        function createLatitudeLines() {
            // åˆ›å»ºçº¬çº¿ï¼ˆèµ¤çº¬çº¿ï¼‰ï¼Œæ¯10åº¦ä¸€æ¡ï¼Œå¿½ç•¥ä¸¤æ
            const radius = 1000;
            const segments = 128;

            // ä»10åº¦åˆ°170åº¦ï¼Œæ¯10åº¦ä¸€æ¡çº¬çº¿
            for (let deg = 10; deg <= 170; deg += 10) {
                const phi = (deg / 180) * Math.PI; // è½¬æ¢ä¸ºå¼§åº¦
                const z = radius * Math.cos(phi); // Zåæ ‡
                const r = radius * Math.sin(phi); // åœ¨XYå¹³é¢ä¸Šçš„åŠå¾„

                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        r * Math.cos(theta),
                        r * Math.sin(theta),
                        z
                    ));
                }

                const latGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const latMaterial = new THREE.LineBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.15,
                    linewidth: 1
                });
                const latLine = new THREE.Line(latGeometry, latMaterial);
                scene.add(latLine);
            }
        }

        // ==========================================
        // 6. åŠ è½½æ•°æ®å¹¶ç”Ÿæˆå‡ ä½•ä½“
        // ==========================================
        async function loadStarData() {
            try {
                const response = await fetch('./star_map.json');
                const data = await response.json();

                // åˆå¹¶é‚»å±…å’ŒèƒŒæ™¯æ˜Ÿæ˜Ÿ
                const neighbors = data.neighbors || [];
                const stars = data.stars || [];
                starsData = [...neighbors, ...stars];

                console.log(`åŠ è½½äº† ${neighbors.length} ä¸ªé‚»å±… + ${stars.length} é¢—èƒŒæ™¯æ˜Ÿ`);
                createStarField(starsData);
            } catch (err) {
                console.error("åŠ è½½ JSON å¤±è´¥:", err);
            }
        }

        function createStarField(stars) {
            const geometry = new THREE.BufferGeometry();

            const positions = [];
            const colors = [];
            const mags = [];

            const SKY_RADIUS = 1000;

            stars.forEach(star => {
                const x = star.pos_cartesian[0];
                const y = star.pos_cartesian[1];
                const z = star.pos_cartesian[2];

                const vec = new THREE.Vector3(x, y, z).normalize().multiplyScalar(SKY_RADIUS);

                // ä¿å­˜å½’ä¸€åŒ–åçš„ä½ç½®ä»¥ä¾¿æ£€ç´¢
                star.normalizedPos = vec;

                positions.push(vec.x, vec.y, vec.z);

                const color = new THREE.Color(star.color_hex);
                colors.push(color.r, color.g, color.b);

                mags.push(star.app_mag);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('mag', new THREE.Float32BufferAttribute(mags, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    useWhiteColor: { value: false }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthTest: false,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            // ä¿å­˜æè´¨å¼•ç”¨ä»¥ä¾¿åˆ‡æ¢é¢œè‰²
            starMaterial = material;

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            console.log(`å·²æ¸²æŸ“ ${stars.length} é¢—æ’æ˜Ÿ`);
        }

        // ==========================================
        // 7. æœç´¢åŠŸèƒ½
        // ==========================================
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        const infoPanel = document.getElementById('info-panel');
        const starName = document.getElementById('star-name');
        const starDetails = document.getElementById('star-details');

        // ç­›é€‰å’Œæ’åºçŠ¶æ€
        let magMin = -2;
        let magMax = 7;
        let currentSort = 'bright'; // 'bright', 'dim', 'near'

        // è§†æ˜Ÿç­‰æ»‘å—
        const magMinSlider = document.getElementById('mag-min');
        const magMaxSlider = document.getElementById('mag-max');
        const magRangeDisplay = document.getElementById('mag-range-display');

        function updateMagDisplay() {
            magRangeDisplay.textContent = `${magMin} åˆ° ${magMax}`;
        }

        magMinSlider.addEventListener('input', (e) => {
            magMin = parseFloat(e.target.value);
            if (magMin > magMax) {
                magMax = magMin;
                magMaxSlider.value = magMax;
            }
            updateMagDisplay();
            refreshFilteredList();
        });

        magMaxSlider.addEventListener('input', (e) => {
            magMax = parseFloat(e.target.value);
            if (magMax < magMin) {
                magMin = magMax;
                magMinSlider.value = magMin;
            }
            updateMagDisplay();
            refreshFilteredList();
        });

        // æ’åºæŒ‰é’®
        document.getElementById('sort-bright').addEventListener('click', () => {
            currentSort = 'bright';
            refreshFilteredList();
        });

        document.getElementById('sort-dim').addEventListener('click', () => {
            currentSort = 'dim';
            refreshFilteredList();
        });

        document.getElementById('sort-near').addEventListener('click', () => {
            currentSort = 'near';
            refreshFilteredList();
        });

        function getFilteredAndSortedStars(query = '') {
            let filtered = starsData.filter(star => {
                const magOk = star.app_mag >= magMin && star.app_mag <= magMax;
                const queryOk = query.length === 0 || star.id.toLowerCase().includes(query);
                return magOk && queryOk;
            });

            // æ’åº
            if (currentSort === 'bright') {
                filtered.sort((a, b) => a.app_mag - b.app_mag);
            } else if (currentSort === 'dim') {
                filtered.sort((a, b) => b.app_mag - a.app_mag);
            } else if (currentSort === 'near') {
                filtered.sort((a, b) => a.dist_ly - b.dist_ly);
            }

            return filtered.slice(0, 50); // é™åˆ¶æ˜¾ç¤ºå‰50ä¸ªç»“æœ
        }

        function refreshFilteredList() {
            const query = searchInput.value.toLowerCase().trim();
            const matches = getFilteredAndSortedStars(query);
            displaySearchResults(matches);
        }

        searchInput.addEventListener('input', (e) => {
            refreshFilteredList();
        });

        function displaySearchResults(matches) {
            if (matches.length === 0) {
                searchResults.innerHTML = '<div style="padding: 8px; color: #666;">æœªæ‰¾åˆ°åŒ¹é…çš„æ˜Ÿæ˜Ÿ</div>';
                return;
            }

            searchResults.innerHTML = matches.map(star => `
            <div class="result-item" data-star-id="${star.id}">
                <strong>${star.id}</strong>
                <div class="star-info">
                    ç±»å‹: ${star.spectral_type} | è§†æ˜Ÿç­‰: ${star.app_mag} | è·ç¦»: ${star.dist_ly} ly
                </div>
            </div>
        `).join('');

            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.result-item').forEach(item => {
                item.addEventListener('click', () => {
                    const starId = item.getAttribute('data-star-id');
                    selectStar(starId);
                });
            });
        }

        function selectStar(starId) {
            selectedStar = starsData.find(s => s.id === starId);

            if (!selectedStar) return;

            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.result-item').forEach(item => {
                item.classList.remove('selected');
                if (item.getAttribute('data-star-id') === starId) {
                    item.classList.add('selected');
                }
            });

            // æ˜¾ç¤ºæ˜Ÿæ˜Ÿä¿¡æ¯
            showStarInfo(selectedStar);

            // ç§»åŠ¨ç›¸æœºæœå‘è¯¥æ˜Ÿæ˜Ÿ
            focusOnStar(selectedStar);

            // æ˜¾ç¤ºé«˜äº®æ ‡è®°
            showHighlight(selectedStar);
        }

        function showStarInfo(star) {
            starName.textContent = star.id;
            const isNeighbor = star.is_neighbor ? 'æ˜¯ (é‚»è¿‘æ’æ˜Ÿ)' : 'å¦ (èƒŒæ™¯æ˜Ÿ)';
            starDetails.innerHTML = `
            <p><strong>ç±»å‹:</strong> ${star.spectral_type}</p>
            <p><strong>è§†æ˜Ÿç­‰:</strong> ${star.app_mag}</p>
            <p><strong>ç»å¯¹æ˜Ÿç­‰:</strong> ${star.abs_mag}</p>
            <p><strong>è·ç¦»:</strong> ${star.dist_ly} å…‰å¹´</p>
            <p><strong>èµ¤ç» (RA):</strong> ${star.ra}Â°</p>
            <p><strong>èµ¤çº¬ (Dec):</strong> ${star.dec}Â°</p>
            <p><strong>è§’ç›´å¾„:</strong> ${star.angular_diameter_mas} mas</p>
            <p><strong>é‚»è¿‘æ’æ˜Ÿ:</strong> ${isNeighbor}</p>
            <p><strong>é¢œè‰²:</strong> <span style="display:inline-block;width:20px;height:20px;background:${star.color_hex};border:1px solid #fff;vertical-align:middle;"></span></p>
        `;
            infoPanel.style.display = 'block';
        }

        function focusOnStar(star) {
            // ç¡®ä¿æ˜Ÿæ˜Ÿæœ‰å½’ä¸€åŒ–ä½ç½®æ•°æ®
            if (!star.normalizedPos) {
                console.error('æ˜Ÿæ˜Ÿç¼ºå°‘å½’ä¸€åŒ–ä½ç½®æ•°æ®:', star.id);
                return;
            }

            const targetPos = star.normalizedPos.clone();
            const n = targetPos.clone().normalize();

            // ç¦ç”¨controlsä»¥é˜²æ­¢å¹²æ‰°åŠ¨ç”»
            controls.enabled = false;

            // è·å–å½“å‰ç›¸æœºè·ç¦»åŸç‚¹çš„è·ç¦»
            const startPos = camera.position.clone();
            const dist = startPos.length() || 0.1;

            // ç›®æ ‡ä½ç½®æ˜¯åœ¨åŸç‚¹çš„å¦ä¸€ä¾§ï¼ˆç›¸å¯¹äºæ˜Ÿæ˜Ÿæ–¹å‘ï¼‰
            // è¿™æ ·ç›¸æœºçœ‹å‘åŸç‚¹æ—¶ï¼Œæ˜Ÿæ˜Ÿå°±ä¼šåœ¨è§†é‡ä¸­å¿ƒ
            const endPos = n.clone().multiplyScalar(-dist);

            let progress = 0;
            const duration = 1000; // 1ç§’
            const startTime = Date.now();

            function animateCamera() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);

                const eased = 1 - Math.pow(1 - progress, 3);

                // åœ¨çƒé¢ä¸Šæ’å€¼ä½ç½®
                camera.position.lerpVectors(startPos, endPos, eased).normalize().multiplyScalar(dist);

                // ç¡®ä¿ç›¸æœºå§‹ç»ˆçœ‹å‘åŸç‚¹ï¼ˆä»è€Œçœ‹å‘èƒŒæ™¯ä¸­çš„æ˜Ÿæ˜Ÿï¼‰
                camera.lookAt(0, 0, 0);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    // åŠ¨ç”»å®Œæˆåé‡æ–°å¯ç”¨controls
                    controls.target.set(0, 0, 0);
                    controls.enabled = true;
                    controls.update();
                }
            }

            animateCamera();
        }

        function showHighlight(star) {
            if (!highlightMarker) return;

            const pos = star.normalizedPos.clone();
            highlightMarker.position.copy(pos);
            highlightMarker.visible = true;

            function updateHighlight() {
                if (selectedStar && selectedStar.id === star.id) {
                    // ä¿æŒæ ‡è®°å§‹ç»ˆé¢å‘ç›¸æœº
                    highlightMarker.lookAt(camera.position);

                    // è®¡ç®—æ˜Ÿæ˜Ÿåœ¨å±å¹•ä¸Šçš„ä½ç½®
                    const vector = pos.clone().project(camera);
                    const isInView = Math.abs(vector.x) <= 1 && Math.abs(vector.y) <= 1 && vector.z < 1;


                    requestAnimationFrame(updateHighlight);
                }
            }
            updateHighlight();
        }

        // ==========================================
        // 8. æ¸²æŸ“å¾ªç¯
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            // ä¿æŒé«˜äº®æ ‡è®°å§‹ç»ˆé¢å‘ç›¸æœº
            if (highlightMarker && highlightMarker.visible) {
                highlightMarker.lookAt(camera.position);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==========================================
        // 9. ç‚¹å‡»æ˜Ÿæ˜Ÿäº¤äº’
        // ==========================================
        function findNearestStar(mouseNDC) {
            let nearestStar = null;
            let minDistance = Infinity;
            const threshold = 0.05; // ç‚¹å‡»å®¹å·®ï¼ˆNDCç©ºé—´ï¼Œå¯è°ƒæ•´ï¼‰

            starsData.forEach(star => {
                if (!star.normalizedPos) return;

                // æŠ•å½±åˆ°å±å¹•ç©ºé—´
                const screenPos = star.normalizedPos.clone().project(camera);

                // æ£€æŸ¥æ˜¯å¦åœ¨è§†é‡å†…
                if (Math.abs(screenPos.x) > 1 || Math.abs(screenPos.y) > 1 || screenPos.z > 1) {
                    return; // åœ¨è§†é‡å¤–æˆ–åœ¨ç›¸æœºåé¢
                }

                // è®¡ç®—è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(screenPos.x - mouseNDC.x, 2) +
                    Math.pow(screenPos.y - mouseNDC.y, 2)
                );

                if (distance < threshold && distance < minDistance) {
                    minDistance = distance;
                    nearestStar = star;
                }
            });

            return nearestStar;
        }

        // è·Ÿè¸ªé¼ æ ‡æŒ‰ä¸‹å’Œæ¾å¼€çš„ä½ç½®ï¼ŒåŒºåˆ†ç‚¹å‡»å’Œæ‹–åŠ¨
        let mouseDownPosition = { x: 0, y: 0 };
        let mouseUpPosition = { x: 0, y: 0 };

        function onMouseDown(event) {
            mouseDownPosition.x = event.clientX;
            mouseDownPosition.y = event.clientY;
        }

        function onStarClick(event) {
            mouseUpPosition.x = event.clientX;
            mouseUpPosition.y = event.clientY;

            // è®¡ç®—é¼ æ ‡ç§»åŠ¨è·ç¦»
            const dx = mouseUpPosition.x - mouseDownPosition.x;
            const dy = mouseUpPosition.y - mouseDownPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // å¦‚æœç§»åŠ¨è·ç¦»å°äºé˜ˆå€¼ï¼Œè®¤ä¸ºæ˜¯ç‚¹å‡»è€Œéæ‹–åŠ¨
            const clickThreshold = 5; // åƒç´ 
            if (distance > clickThreshold) {
                return; // æ˜¯æ‹–åŠ¨æ“ä½œï¼Œä¸é€‰æ‹©æ˜Ÿæ˜Ÿ
            }

            // è®¡ç®—å½’ä¸€åŒ–è®¾å¤‡åæ ‡ (NDC: -1 åˆ° +1)
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // æŸ¥æ‰¾æœ€è¿‘çš„æ˜Ÿæ˜Ÿ
            const clickedStar = findNearestStar(mouse);

            if (clickedStar) {
                selectStar(clickedStar.id);
            }
        }

        // æ·»åŠ é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
        renderer.domElement.addEventListener('mousedown', onMouseDown, false);
        renderer.domElement.addEventListener('click', onStarClick, false);

        // ==========================================
        // 10. ç›¸æœºç¼©æ”¾æ§åˆ¶ï¼ˆæ²¿å½“å‰æ–¹å‘ç§»åŠ¨ï¼‰
        // ==========================================
        const minDistance = 50;  // è·ç¦»åŸç‚¹çš„æœ€å°è·ç¦»
        const maxDistance = 900; // è·ç¦»åŸç‚¹çš„æœ€å¤§è·ç¦»
        const zoomSpeed = 50;    // æ¯æ¬¡æ»šè½®æ»šåŠ¨çš„ç§»åŠ¨è·ç¦»

        function onMouseWheel(event) {
            event.preventDefault();

            // è·å–ç›¸æœºå½“å‰ä½ç½®å’Œè·ç¦»
            const currentDistance = camera.position.length();

            // æ ¹æ®æ»šè½®æ–¹å‘è°ƒæ•´è·ç¦»
            const delta = event.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            let newDistance = currentDistance + delta;

            // é™åˆ¶åœ¨èŒƒå›´å†…
            newDistance = Math.max(minDistance, Math.min(maxDistance, newDistance));

            // æ²¿ç€å½“å‰æ–¹å‘ç§»åŠ¨ç›¸æœºï¼ˆä¿æŒæ–¹å‘ï¼Œåªæ”¹å˜è·ç¦»ï¼‰
            const direction = camera.position.clone().normalize();
            camera.position.copy(direction.multiplyScalar(newDistance));

            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function resetCamera() {
            // è¿”å›åŸç‚¹
            camera.position.set(0, 0, 0.1);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        // æ·»åŠ æ»šè½®äº‹ä»¶ç›‘å¬å™¨
        renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });

        // æ·»åŠ é‡ç½®æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('reset-button').addEventListener('click', resetCamera);

        // æ·»åŠ é¢œè‰²åˆ‡æ¢æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        let isWhiteMode = false;
        const colorToggleButton = document.getElementById('color-toggle-button');
        colorToggleButton.addEventListener('click', () => {
            isWhiteMode = !isWhiteMode;
            if (starMaterial) {
                starMaterial.uniforms.useWhiteColor.value = isWhiteMode;
            }
            colorToggleButton.textContent = isWhiteMode ? 'åˆ‡æ¢ä¸ºå½©è‰²' : 'åˆ‡æ¢ä¸ºç™½è‰²';
        });

        // å¯åŠ¨
        createHighlightMarker();
        createGalacticPlane();
        createCelestialPoles();
        createCelestialMeridians();
        createPolarCrosses();
        createPolarCircles();
        createLatitudeLines();
        loadStarData();
        animate();

    </script>
</body>

</html>